[
  {
    "objectID": "pages/99-contributors.html",
    "href": "pages/99-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "This course was originally written by Christopher Woods and published at https://chryswoods.com/beginning_python/. Some changes were made by the ACRC at the University of Bristol. The course was revised by Matt Williams, see https://milliams.com/courses/beginning_python/.\n\nChristopher Woods\nMatt Williams",
    "crumbs": [
      "Contributors"
    ]
  },
  {
    "objectID": "pages/03-lists.html",
    "href": "pages/03-lists.html",
    "title": "Lists",
    "section": "",
    "text": "Until now all the variables we have used have contained a single piece of information, for example, a = 4 makes a variable a containing a single number, 4. It’s very common in programming (and in fact real life) to want to refer to collections of this. For example a shopping list contains a list of items you want to buy, or a car park contains a set of cars.\nCreate a new file by going to File → New → Text File. Rename it (using the left-hand file pane in JupyterLab with right-click Rename) to list.py. Inside that file write the following:\n\n\n\nlist.py\n\nmy_list = [\"cat\", \"dog\", \"horse\"]\n\nprint(my_list)\n\n\nRun this script in the terminal with python list.py and look at the output.\nThis will create a Python list with three elements and assign it to the variable my_list. The square brackets [ and ] in this case mean “create a list” and the elements of the list are separated by commas. As with previous variable types, you can print lists by passing their name to the print() function.\nYou can have as many items in a list as you like, even zero items. An empty list could look like:\n\nmy_list = []\n\nAnd a list with six different numbers could look like:\n\nmy_list = [32, 65, 3, 867, 3, -5]\n\nYou can even have a mixture of different type of data in a list:\n\nmy_list = [5, 34.6, \"Hello\", -6]\n\n\n\n\n\n\n\nExercise 1\n\n\n\nEdit the list so that it has some more items in it. Try adding some different data types and even rearranging the items. Make sure you save the file and rerun it in the terminal and check that the output matches what you expect.\nanswer\n\n\n\nIndexing\nThe power of Python’s lists comes not simply from being able to hold many pieces of data but from being able to get specific pieces of data out. The primary method of this is called indexing. Indexing a list in Python is done using the square brackets []. This is a different use of the square brackets to that which we saw above for making a list.\nTo get a single element out of a list you write the name of the variable followed by a pair of square brackets with a single number between them:\n\n\n\nlist.py\n\nmy_list = [\"cat\", \"dog\", \"horse\"]\n\nmy_element = my_list[1]\n\nprint(my_element)\n\n\nThe code my_list[1] means “give me the number 1 element of the list my_list”. Run this code and see what you get. Is it what you expect?\nYou’ll probably notice that it prints dog whereas you may have expected it to print cat. This is because in Python you count from zero when indexing lists and so index 1 refers to the second item in the list. To get the first item you must use the index 0. This “zero-indexing” is very common and is used by most programming languages.\n\n\n\n\n\n\nExercise 2\n\n\n\nTry accessing some different elements from the list by putting in different number between the square brackets.\nanswer\n\n\n\n\nReverse indexing\nPutting a single positive number in the square brackets gives us back the element which is that distance from the start of the list, but what if we wanted the last element? If we know the length of the list (in our case here, 3 elements) then we can use that to know the index of the last element (in this case, 2), but perhaps we don’t know (or don’t want to have to check) how long the list is.\nIn this case we can use Python’s reverse indexing by placing a negative integer in the square brackets:\n\n\n\nlist.py\n\nmy_list = [\"cat\", \"dog\", \"horse\"]\n\nmy_element = my_list[-1]\n\nprint(my_element)\n\n\nIf you run this code then you will see that it prints horse which is the last item in the list. Using negative numbers allows you to count backwards from the end of the list so that -1 is the last item, -2 is the second-last item etc.\n\n\nPython errors\nIndexing lists is likely the first time you will see a Python error. Seing Python errors (also sometimes called exceptions) is not a sign that you’re a bad programmer or that you’re doing something terrible. All Python programmers, even those that have been using it for 20 years will still see Python errors on their screen.\nThey are in fact a very useful feedback mechanism from the computer to the programmer but that can be a bit daunting when you first see them. Let’s look at an example and I will explain how to read it. Let’s start by creating an error.\nA Python list with three elements will not have an element at index 6 (the highest index in that case would be 2) so let’s have a look at what happens if we ask for it anyway:\n\n\n\nlist.py\n\nmy_list = [\"cat\", \"dog\", \"horse\"]\n\nmy_element = my_list[6]\n\nprint(my_element)\n\n\nRunning this you will see the following printed to the screen:\nTraceback (most recent call last):\n  File \"/home/matt/tmp/beginning_python/list.py\", line 3, in &lt;module&gt;\n    my_element = my_list[6]\nIndexError: list index out of range\nwhich a very dense collection of information. I always start by reading the last line of an error as that is usually where the most useful information is.\nThe last line is IndexError: list index out of range which has two parts to it. The first is the word before the colon which tells you the type of the exception is an IndexError, i.e. an error when indexing. The second part of that line is usually a slightly more descriptive message, in this case telling us that the specific problem was that the index was “out of range”, i.e. too high or too low.\nMoving to the line above that, we see printed the line of code, copied from our script, at which the exception occured. This, along with the line above that which gives the file name and line number within that file, are essential in larger scripts to track down where the problem came from.\nTake your time to read the error messages when they are printied to the screen, they will most likely help you solve the issue. If you think that you’ve fixed the problem but the error persists, make sure that you’ve saved the script file and rerun your code afterwards.\n\n\nAdding things to lists\nLists in Python are dynamic, meaning that they can change size during your script. You can add items to the end of your list by using the append function. The append function is a little different to other functions that we’ve used so far (like print and range) in that it is a part of the list data type so we use it like:\n\nmy_list = [\"cat\", \"dog\", \"horse\"]\n\nmy_list.append(\"quokka\")\n\nprint(my_list)\n\nHere you see we gave the name of our list (my_list) followed it by a dot (.) and then the name of the function that we wanted to call (append). Functions which are part of data types like this are sometimes called methods.\nWe might describe the middle line here as “calling the append method on the object my_list”.\n\n\nExtended: Slicing\nAs well as being able to select individual elements from a list, you can also grab sections of it at once. This process of asking for subsections of a list of called slicing. Slicing starts out the same way as standard indexing (i.e. with square brackets) but instead of putting a single number between them, you put multiple numbers separated by colons.\nBetween the square brackets you put two numbers, the starting index and the ending index. So, to get the elements from index 2 to index 4, you do:\n\nmy_list = [3, 5, \"green\", 5.3, \"house\", 100, 1]\n\nmy_slice = my_list[2:5]\n\nprint(my_slice)\n\nRun this code and look at the output.\nYou see that is printed ['green', 5.3, 'house'] which is index 2 ('green'), index 3 (5.3) and index 4 ('house'). Notice that it did not give us the element at index 5 and that is because with slicing, Python will give you the elements from the starting index up to, but not including, the end index.\nThis can be confusing at first but a trick that I use to keep it straight is to count the commas in the list and treat the indexes as referring to those. So from the example here:\n\n[3, 5, \"green\", 5.3, \"house\", 100, 1]\n\n  ↑  ↑        ↑    ↑        ↑    ↑\n  1  2        3    4        5    6\nso my_list[2:5] will make a cut at index 2 and index 5:\n\n[3, 5, \"green\", 5.3, \"house\", 100, 1]\n\n     ↑                      ↑\n     2                      5\nand only give you the things between them:\n[    , \"green\", 5.3, \"house\",       ]\n     ↑                      ↑\n     2                      5\nso we end up with:\n['green', 5.3, 'house']\n\n\n\n\n\n\nExercise 3\n\n\n\nEdit your script to print various slices of your list. If you get an error printed, make sure you understand what it is telling you.\nanswer",
    "crumbs": [
      "Lists"
    ]
  },
  {
    "objectID": "pages/06-dictionaries.html",
    "href": "pages/06-dictionaries.html",
    "title": "Dictionaries",
    "section": "",
    "text": "Lists let you store lots of variables, and to access them by their location in the list. However, there are times when you want to store lots of variables, but access them using more complex relationships. One example is a dictionary, which lets you store variables and access them using a key.\nDictionaries in Python are created using curly brackets. Make a new file called dict.py and put this in it:\n\n\n\ndict.py\n\nsounds = {\"cat\": \"meow\", \"dog\": \"woof\", \"horse\": \"neigh\"}\n\ncat_sound = sounds[\"cat\"]\n\nprint(cat_sound)\n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\nmeow\n\n\nWhat we did here was create a dictionary on the first line. A dictionary is created using curly brackets ({}), in much the same way as square brackets are used for creating lists. The dictionary we created here has three items in it where each item comprises a key and a value. The value is the real data that we want to keep hold of and the key is how we can get at the data we want. The key and value are separated by a colon and each key-value pair is separated by a comma.\nOn the next line we access the data in the dictionary sounds. Again, like lists we use the square brackets to ask questions of our data. In this case we’re asking the dictionary to give us the value associated with the key \"cat\" and so it will return to us \"meow\".\nSince dictionaries can be quite large and it can sometimes be hard to see which parts are keys and which are values, it is possible to write dictionaries over multiple lines, one line per key-value item:\n\n\n\ndict.py\n\nsounds = {\n    \"cat\": \"meow\",\n    \"dog\": \"woof\",\n    \"horse\": \"neigh\"\n}\n\ncat_sound = sounds[\"cat\"]\n\nprint(cat_sound)\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nEdit dict.py to ask for the sound for the dog and the horse. - What happens if you ask for an animal that isn’t in the dictionary?\nanswer\n\n\n\nAdding new data into dictionaries\nAs with lists, dictionaries are dynamic so we can add entries into a dictionary.\nLet’s say that we want to add in a new sound for a cow into our sounds dictionary. The key that the data will have will be \"cow\" and the value will be \"moo\". To do so we put sounds[\"cow\"] on the left-hand side of a variable assignment expression, as if we’re making a new variable. On the right goes the data that we want to put into the dictionary:\n\n\n\ndict.py\n\nsounds = {\n    \"cat\": \"meow\",\n    \"dog\": \"woof\",\n    \"horse\": \"neigh\"\n}\n\nsounds[\"cow\"] = \"moo\"\n\nprint(sounds)\n\n\nThis is saying that we want the value \"moo\" associated with the key \"cow\" in the dictionary sounds.\nRunning it, we see:\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\n{'cat': 'meow', 'dog': 'woof', 'horse': 'neigh', 'cow': 'moo'}\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nEdit dict.py so that the dictionary is initially defined with only the cat and dog entries. Add the entry for the horse and then the cow dynamically.\nanswer\n\n\n\n\nLooping over dictionaries\nWhen discussing for loops you were told that Python allows you to loop over lots of different types of data such as lists, strings and ranges. We can add dictionaries to that set.\nTo discover how it works, let’s do the naïve thing first and just see what happens when we loop over a dictionary:\n\n\n\ndict.py\n\nsounds = {\n    \"cat\": \"meow\",\n    \"dog\": \"woof\",\n    \"horse\": \"neigh\"\n}\n\nfor thing in sounds:\n    print(thing)\n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\ncat\ndog\nhorse\n\n\nHopefully, you recognise those as the keys from the dictionary. So, it seems that when looping over a dictionary we will be given the keys.\nWhat if, for example, you wanted to loop over the values instead. Well, there is a method on dictionaries called values which gives you just those so that you can loop over them:\n\n\n\ndict.py\n\nsounds = {\n    \"cat\": \"meow\",\n    \"dog\": \"woof\",\n    \"horse\": \"neigh\"\n}\n\nfor sound in sounds.values():\n    print(sound)    \n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\nmeow\nwoof\nneigh\n\n\nIf we want to loop over the dictionary and get both the keys and the values, there is a method called items. Since it will be giving us two things each loop iteration, we’ll have to use the same trick as we did with enumerate and give two variable names in the for loop declaration:\n\n\n\ndict.py\n\nsounds = {\n    \"cat\": \"meow\",\n    \"dog\": \"woof\",\n    \"horse\": \"neigh\"\n}\n\nfor animal, sound in sounds.items():\n    print(animal, \"goes\", sound)\n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\ncat goes meow\ndog goes woof\nhorse goes neigh\n\n\nThe items method gives us two pieces of data where the first is always the key and the second if always the value. We give the keys the name animal and the values the name sound. We can then use both those variables in the loop body.\n\n\nUses for dictionaries\nDictionaries can be used for any key-value mapping. The example above was a mapping of an animal species (as a string) to an animal sound ( as a string). You can use any data type you wish as the value in a dictionary. For example you might make a dictionary containing the population of some cities in millions (as a float):\n\ncensus = {\n    \"London\": 8.615,\n    \"Paris\": 2.244,\n    \"Rome\": 2.627,\n}\n\nor one which contains a list of authors as the key (as a string) and their books (as a list of strings):\n\nbookshelf = {\n    \"Terry Pratchett\": [\"Mort\", \"Jingo\", \"Truckers\"],\n    \"Jane Austen\": [\"Sense and Sensibility\", \"Pride and Prejudice\"],\n    \"Charles Dickens\": [\"Oliver Twist\"],\n}\n\n\n\n\n\n\n\nExercise 3\n\n\n\nMake a dictionary with the keys being the name of countries and the value being the country’s capital city. Loop over the dictionary and print something like \"The capital of France is Paris\" for each item.\nanswer\n\n\nTo summarise the different things we can pass to loops and the data that we get given each iteration:\n\nlist: the items in the list\nstr: the characters in the string\nenumerate(): a pair of the index of the item and the item itself\ndict: the keys of the dictionary\ndict.keys(): the keys from the dictionary\ndict.values(): the values from the dictionary\ndict.items(): the key-value pairs from the dictionary",
    "crumbs": [
      "Dictionaries"
    ]
  },
  {
    "objectID": "pages/01-getting-started.html",
    "href": "pages/01-getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "A Python script is a simple text file containing a set of instructions. As long as these instructions are written in the “Python Programming Language” then the computer will be able to understand them and perform the tasks we’ve asked.\nTo create our script, go to the text editor pane in JupyterLab and type into it:\n\n\n\nscript.py\n\nprint(\"Hello from Python\")\n\n\nThen go to File → Save File and you’ll see the small black circle next to the words “untitled.txt” in the tab change to a cross.\nWe’ve just saved our Python script with the name “untitled.txt” but we should give it a more descriptive name. In the far left pane you will see a list of files. Right click on “untitled.txt” and select Rename. Python files end in the extension “.py” so change its name to “script.py”.\nYou should now see that the name of the text editor tab reads script.py.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "pages/01-getting-started.html#writing-our-first-script",
    "href": "pages/01-getting-started.html#writing-our-first-script",
    "title": "Getting Started",
    "section": "",
    "text": "A Python script is a simple text file containing a set of instructions. As long as these instructions are written in the “Python Programming Language” then the computer will be able to understand them and perform the tasks we’ve asked.\nTo create our script, go to the text editor pane in JupyterLab and type into it:\n\n\n\nscript.py\n\nprint(\"Hello from Python\")\n\n\nThen go to File → Save File and you’ll see the small black circle next to the words “untitled.txt” in the tab change to a cross.\nWe’ve just saved our Python script with the name “untitled.txt” but we should give it a more descriptive name. In the far left pane you will see a list of files. Right click on “untitled.txt” and select Rename. Python files end in the extension “.py” so change its name to “script.py”.\nYou should now see that the name of the text editor tab reads script.py.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "pages/01-getting-started.html#running-our-script",
    "href": "pages/01-getting-started.html#running-our-script",
    "title": "Getting Started",
    "section": "Running our script",
    "text": "Running our script\nTo run the script that we’ve just written and saved, we move to the pane on the right with the label “Terminal 1”. This pane gives us access to a command line interface to our computer. This is the same interface that you have in a Command Prompt in Windows or a Terminal on MacOS or Linux. We type commands in here and the computer runs the programmes we ask it to.\nThe only command we need to know about here is python which we run by typing python in that window, followed by a space, followed by the name of our script file (including the “.py” extension) and then pressing enter:\n\n\nTerminal/Command Prompt\n\npython script.py\n\nIf you do that you should see, printed to the terminal:\n\n\nHello from Python\n\n\nCongratulations, you’ve just written and executed your very first Python programme!\nIf you see an error here then you may need to use a slightly different command to run Python. Try running your script with python3 script.py (note the “3”) as described in this video.",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "pages/01-getting-started.html#explanation",
    "href": "pages/01-getting-started.html#explanation",
    "title": "Getting Started",
    "section": "Explanation",
    "text": "Explanation\nThis was a simple script. Python is a language designed to help you write everything from small and simple scripts to large complete programs. In my opinion Python is one of the best prototyping languages, and the best language for writing programs that glue together or provide interfaces to other programs.\nThis script has introduced three of the basic building blocks of Python;\n\nA function print. Functions are instructions that tell Python to do something, in this case print tells Python to print the following string to the screen. Functions are “called” by following them with a pair of parentheses (). Whatever we put between those parentheses are called “arguments” and specify exactly what the function should do.\nA string \"Hello from Python!\". A string is just a piece of text, which can contain multiple lines. Strings are enclosed in double quotes.\nA line of code print(\"Hello from Python!\"). A line of code forms a complete instruction which can be executed by Python. Python executes each line of code, one at a time in order, moving from the top of the file downwards until it reaches the end of the file.\n\nImportant things to remember for this section are:\n\nAlways save your Python scripts after making a change (the black circle means there are unsaved changes)\nAlways give your Python scripts a “.py” extension\nPython code goes in the text editor window while you run the script from the terminal window",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "pages/01-getting-started.html#how-to-read-these-notes",
    "href": "pages/01-getting-started.html#how-to-read-these-notes",
    "title": "Getting Started",
    "section": "How to read these notes",
    "text": "How to read these notes\nIn these notes, any time that we’re seeing a full Python script, we’ll see it written like the following:\n\n\n\nscript.py\n\nprint(\"Hello from Python\")\n\n\nHere, the name that we give the file (script.py) is above the code block, and the contents of the file (print(\"Hello from Python\")) are below it.\nWe’ll denote “run in the Terminal” with a Terminal/Command Prompt sign at the top of the block. So when we ask you to run your script, it will look like this:\n\n\nTerminal/Command Prompt\n\npython script.py\n\nAnd we see the expected output displayed below it.\nBy contrast, any time we’re just showing you a small snippet of code, for example to demonstrate a point, it will be shown like:\n\nprint(\"Hello from Python\")\n\nHello from Python",
    "crumbs": [
      "Getting Started"
    ]
  },
  {
    "objectID": "answers/answer_print_different_string.html",
    "href": "answers/answer_print_different_string.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Here we change the line of code in our script to have the string \"Hello Matt\" instead of \"Hello from Python!\".\n\n\n\nscript.py\n\nprint(\"Hello Matt\")\n\n\nWhen we run our changed script we see that it now prints our new string to the screen:\n\n\nTerminal/Command Prompt\n\npython script.py\n\n\n\nHello Matt\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_first_slicing.html",
    "href": "answers/answer_first_slicing.html",
    "title": "Beginning Python",
    "section": "",
    "text": "We make a list and then select a few slices of it:\n\n\n\nlist.py\n\nmy_list = [3, 5, \"green\", 5.3, \"house\", 100, 1]\n\nprint(my_list[2:4])\nprint(my_list[3:-2])\nprint(my_list[0:1])\nprint(my_list[-4:-1])\n\n\nThis selects everything from the number 2 index up to, but not including the number 4 index, i.e. the 2 and 3 indexes:\n[2:4]\nThis starts at index 3 and goe as far as index -2 (which is the same as index 5 in this list):\n[3:-2]\nThis starts at the beginning of the list and stops before index 1, giving us a list with just one item:\n[0:1]\nThis starts at index -4 (i.e. index 3) and goes until index -1 (i.e. index 6):\n[-4:-1]\n\n\nTerminal/Command Prompt\n\npython list.py\n\n\n\n['green', 5.3]\n[5.3, 'house']\n[3]\n[5.3, 'house', 100]\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_practice_questions.html",
    "href": "answers/answer_practice_questions.html",
    "title": "Beginning Python",
    "section": "",
    "text": "%%writefile ex1.py\n\nanimal_list = [\"cat\", \"dog\", \"elephant\", \"minnow\", \"beaver\"]\n\nprint(animal_list)\nOverwriting ex1.py\n%run ex1.py\n['cat', 'dog', 'elephant', 'minnow', 'beaver']\n\n\n\nWe can pass multiple argumets to print():\n%%writefile ex2.py\n\nanimal_list = [\"cat\", \"dog\", \"elephant\", \"minnow\", \"beaver\"]\n\nfor animal in animal_list:\n    print(\"Species:\", animal)\nOverwriting ex2.py\n%run ex2.py\nSpecies: cat\nSpecies: dog\nSpecies: elephant\nSpecies: minnow\nSpecies: beaver\n\n\n\n%%writefile ex3.py\n\nmy_numbers = [65, 54, 17, 78, 66, 24, 32, 80, 79, 95]\n\nfor num in my_numbers:\n    if num &gt; 50:\n        print(num)\nOverwriting ex3.py\n%run ex3.py\n65\n54\n78\n66\n80\n79\n95\n\n\n\nWhen creating a chain of if/elif/else, you should put the most specific checks first, otherwise they will be swamped by the more general checks.\n%%writefile ex4.py\n\nfor i in range(1, 21):\n    if i % 3 == 0 and i % 5 == 0:\n        print(\"foo\")\n    elif i % 3 == 0:\n        print(\"ook\")\n    else:\n        print(i)\nOverwriting ex4.py\n%run ex4.py\n1\n2\nook\n4\n5\nook\n7\n8\nook\n10\n11\nook\n13\n14\nfoo\n16\n17\nook\n19\n20\n\n\n\nWe can check multiple things in a single if statement by chaining them with or or and:\n%%writefile ex5.py\n\nartworks = {\n    \"Sunflowers\": \"van Gogh\",\n    \"The Starry Night\": \"van Gogh\",\n    \"The Night Watch\": \"Rembrandt\",\n    \"The Two Fridas\": \"Kahlo\",\n    \"Balloon Girl\": \"Banksy\",\n    \"Devolved Parliament\": \"Banksy\",\n    \"Going to Work\": \"Lowry\",\n}\n\nfor artwork, artist in artworks.items():\n    if \"h\" in artist or len(artwork) &gt; 13:\n        print(artwork, \"by\", artist)\nOverwriting ex5.py\n%run ex5.py\nSunflowers by van Gogh\nThe Starry Night by van Gogh\nThe Night Watch by Rembrandt\nThe Two Fridas by Kahlo\nDevolved Parliament by Banksy\n\n\n\nYou cannot have repeated keys in a dictionary so we need some way of relating the same key with multiple values. This is best done with a list as the value.\nEven if an artist has only one painting, we still use a list. This is becasue it allows any code which reads the values to know that it will always get a list, rather than sometimes a list, sometimes a string.\n%%writefile ex6.py\n\ngallery = {\n    \"van Gogh\": [\"Sunflowers\", \"The Starry Night\"],\n    \"Rembrandt\": [\"The Night Watch\"],\n    \"Kahlo\": [\"The Two Fridas\"],\n    \"Banksy\": [\"Balloon Girl\", \"Devolved Parliament\"],\n    \"Lowry\": [\"Going to Work\"],\n}\n\nfor artist, paintings in gallery.items():\n    if len(paintings) &gt; 1:\n        for painting in paintings:\n            if len(painting.split()) &gt; 1:\n                print(painting, \"by\", artist)\nOverwriting ex6.py\n%run ex6.py\nThe Starry Night by van Gogh\nBalloon Girl by Banksy\nDevolved Parliament by Banksy\n\n\n\n%%writefile ex7.py\n\nword_list = [\"to\", \"be\", \"or\", \"not\", \"to\", \"be\"]\n\nword_couts = {}\n\nfor word in word_list:\n    if word in word_couts:\n        word_couts[word] += 1\n    else:\n        word_couts[word] = 1\n\nprint(word_couts)\nOverwriting ex7.py\n%run ex7.py\n{'to': 2, 'be': 2, 'or': 1, 'not': 1}"
  },
  {
    "objectID": "answers/answer_practice_questions.html#answers-for-the-practice-questions",
    "href": "answers/answer_practice_questions.html#answers-for-the-practice-questions",
    "title": "Beginning Python",
    "section": "",
    "text": "%%writefile ex1.py\n\nanimal_list = [\"cat\", \"dog\", \"elephant\", \"minnow\", \"beaver\"]\n\nprint(animal_list)\nOverwriting ex1.py\n%run ex1.py\n['cat', 'dog', 'elephant', 'minnow', 'beaver']\n\n\n\nWe can pass multiple argumets to print():\n%%writefile ex2.py\n\nanimal_list = [\"cat\", \"dog\", \"elephant\", \"minnow\", \"beaver\"]\n\nfor animal in animal_list:\n    print(\"Species:\", animal)\nOverwriting ex2.py\n%run ex2.py\nSpecies: cat\nSpecies: dog\nSpecies: elephant\nSpecies: minnow\nSpecies: beaver\n\n\n\n%%writefile ex3.py\n\nmy_numbers = [65, 54, 17, 78, 66, 24, 32, 80, 79, 95]\n\nfor num in my_numbers:\n    if num &gt; 50:\n        print(num)\nOverwriting ex3.py\n%run ex3.py\n65\n54\n78\n66\n80\n79\n95\n\n\n\nWhen creating a chain of if/elif/else, you should put the most specific checks first, otherwise they will be swamped by the more general checks.\n%%writefile ex4.py\n\nfor i in range(1, 21):\n    if i % 3 == 0 and i % 5 == 0:\n        print(\"foo\")\n    elif i % 3 == 0:\n        print(\"ook\")\n    else:\n        print(i)\nOverwriting ex4.py\n%run ex4.py\n1\n2\nook\n4\n5\nook\n7\n8\nook\n10\n11\nook\n13\n14\nfoo\n16\n17\nook\n19\n20\n\n\n\nWe can check multiple things in a single if statement by chaining them with or or and:\n%%writefile ex5.py\n\nartworks = {\n    \"Sunflowers\": \"van Gogh\",\n    \"The Starry Night\": \"van Gogh\",\n    \"The Night Watch\": \"Rembrandt\",\n    \"The Two Fridas\": \"Kahlo\",\n    \"Balloon Girl\": \"Banksy\",\n    \"Devolved Parliament\": \"Banksy\",\n    \"Going to Work\": \"Lowry\",\n}\n\nfor artwork, artist in artworks.items():\n    if \"h\" in artist or len(artwork) &gt; 13:\n        print(artwork, \"by\", artist)\nOverwriting ex5.py\n%run ex5.py\nSunflowers by van Gogh\nThe Starry Night by van Gogh\nThe Night Watch by Rembrandt\nThe Two Fridas by Kahlo\nDevolved Parliament by Banksy\n\n\n\nYou cannot have repeated keys in a dictionary so we need some way of relating the same key with multiple values. This is best done with a list as the value.\nEven if an artist has only one painting, we still use a list. This is becasue it allows any code which reads the values to know that it will always get a list, rather than sometimes a list, sometimes a string.\n%%writefile ex6.py\n\ngallery = {\n    \"van Gogh\": [\"Sunflowers\", \"The Starry Night\"],\n    \"Rembrandt\": [\"The Night Watch\"],\n    \"Kahlo\": [\"The Two Fridas\"],\n    \"Banksy\": [\"Balloon Girl\", \"Devolved Parliament\"],\n    \"Lowry\": [\"Going to Work\"],\n}\n\nfor artist, paintings in gallery.items():\n    if len(paintings) &gt; 1:\n        for painting in paintings:\n            if len(painting.split()) &gt; 1:\n                print(painting, \"by\", artist)\nOverwriting ex6.py\n%run ex6.py\nThe Starry Night by van Gogh\nBalloon Girl by Banksy\nDevolved Parliament by Banksy\n\n\n\n%%writefile ex7.py\n\nword_list = [\"to\", \"be\", \"or\", \"not\", \"to\", \"be\"]\n\nword_couts = {}\n\nfor word in word_list:\n    if word in word_couts:\n        word_couts[word] += 1\n    else:\n        word_couts[word] = 1\n\nprint(word_couts)\nOverwriting ex7.py\n%run ex7.py\n{'to': 2, 'be': 2, 'or': 1, 'not': 1}"
  },
  {
    "objectID": "answers/answer_first_list.html",
    "href": "answers/answer_first_list.html",
    "title": "Beginning Python",
    "section": "",
    "text": "We have changed our list by adding two more items to the end of it. We add an integer, 7 and a new string, \"quail\". Each is still separated by a comma:\n\n\n\nlist.py\n\nmy_list = [\"cat\", \"dog\", \"horse\", 7, \"quail\"]\n\nprint(my_list)\n\n\n\n\nTerminal/Command Prompt\n\npython list.py\n\n\n\n['cat', 'dog', 'horse', 7, 'quail']\n\n\nHere we edit our list so that the items are all in a different order:\n\n\n\nlist.py\n\nmy_list = [\"quail\", \"cat\", 7, \"dog\", \"horse\"]\nprint(my_list)\n\n\n\n\nTerminal/Command Prompt\n\npython list.py\n\n\n\n['quail', 'cat', 7, 'dog', 'horse']\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_loop_list_string.html",
    "href": "answers/answer_loop_list_string.html",
    "title": "Beginning Python",
    "section": "",
    "text": "We start with the same list we had in the chapter.\n\n\n\nloop.py\n\nwords = [\"Hello\", \"Python\"]\n\nfor word in words:\n    print(word)\n\n\nEach item in the list gets printed on its own line:\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\nHello\nPython\n\n\nIf we loop over a string:\n\n\n\nloop.py\n\nphrase = \"Hello Python\"\n\nfor letter in phrase:\n    print(letter)\n\n\nWe see that each character in the string gets printed on its own line:\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\nH\ne\nl\nl\no\n \nP\ny\nt\nh\no\nn\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_if_leap_year.html",
    "href": "answers/answer_if_leap_year.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Whenever solving a problem like this, it’s always good to build it up one step at a time. You’ll be tempted to jump right to the solution but it’s much easier to take very small steps. It might seem extreme but the first step in a solution should do almost nothing. I tend to start by simply outputting the input of my program to make sure that at least the input is being read correctly, before trying to do any logic with it:\n\n\n\nleap_year.py\n\nyear = int(input(\"Enter a year: \"))\n\nprint(year)\n\n\npython leap_year.py\n\n\nEnter a year: 2024\n2024\n\n\nNow we know that the year is being read in correctly (note that since we’re reading in a number, we explicitly convert it with int()).\n\nYes if divisible by \\(4\\)\nThe first step is to implement the simplest of the logical checks: is the year divisible by \\(4\\)? If it is, print out an appropriate message:\n\n\n\nleap_year.py\n\nyear = int(input(\"Enter a year: \"))\n\nif year % 4 == 0:\n    print(year, \"is a leap year\")\n\n\nand check that it works for a know leap year.\npython leap_year.py\n\n\nEnter a year: 2024\n2024 is a leap year\n\n\nFor a year that we know is not a leap year, what do we get:\npython leap_year.py\n\n\nEnter a year: 2023\n\n\nWe get no output, so let’s fix that next, by adding an else:\n\n\n\nleap_year.py\n\nyear = int(input(\"Enter a year: \"))\n\nif year % 4 == 0:\n    print(year, \"is a leap year\")\nelse:\n    print(year, \"is not a leap year\")\n\n\npython leap_year.py\n\n\nEnter a year: 2024\n2024 is a leap year\n\n\npython leap_year.py\n\n\nEnter a year: 2023\n2023 is not a leap year\n\n\nSo far it’s looking like it’s doing the right thing. We have a working leap year calculator which covers most cases correctly.\n\n\nBut not if divisible by \\(100\\)\nLet’s check the next corner case: what happens if the year is divisible by 100. The rules say that this should not be a leap year:\npython leap_year.py\n\n\nEnter a year: 100\n100 is a leap year\n\n\nSo it’s currently getting this wrong. We need to add in a check to see if the year is divisible by 100 and set it to be labelled as not a leap year.\nHere we need to be careful as any number which is divisible by \\(100\\) is also divisible by \\(4\\) but we want a special thing to happen in the former case. The divisible-by-\\(100\\) check is more specific than the divisible-by\\(4\\) check, so it must come first in the if/elif/else chain:\n\n\n\nleap_year.py\n\nyear = int(input(\"Enter a year: \"))\n\nif year % 100 == 0:\n    print(year, \"is not a leap year\")\nelif year % 4 == 0:\n    print(year, \"is a leap year\")\nelse:\n    print(year, \"is not a leap year\")\n\n\npython leap_year.py\n\n\nEnter a year: 2024\n2024 is a leap year\n\n\npython leap_year.py\n\n\nEnter a year: 2023\n2023 is not a leap year\n\n\npython leap_year.py\n\n\nEnter a year: 1900\n1900 is not a leap year\n\n\n\n\nBut yes if divisible by \\(400\\)\nThe code is working for all those cases correctly, however, the last condition to think about is what happens for the year 2000:\npython leap_year.py\n\n\nEnter a year: 2000\n2000 is not a leap year\n\n\nThis year should be a leap year as it is divisible by \\(400\\). Again this is more specific than the previous two so must be added before them in the chain:\n\n\n\nleap_year.py\n\nyear = int(input(\"Enter a year: \"))\n\nif year % 400 == 0:\n    print(year, \"is a leap year\")\nelif year % 100 == 0:\n    print(year, \"is not a leap year\")\nelif year % 4 == 0:\n    print(year, \"is a leap year\")\nelse:\n    print(year, \"is not a leap year\")\n\n\npython leap_year.py\n\n\nEnter a year: 2024\n2024 is a leap year\n\n\npython leap_year.py\n\n\nEnter a year: 2023\n2023 is not a leap year\n\n\npython leap_year.py\n\n\nEnter a year: 1900\n1900 is not a leap year\n\n\npython leap_year.py\n\n\nEnter a year: 2000\n2000 is a leap year\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_country_dictionary.html",
    "href": "answers/answer_country_dictionary.html",
    "title": "Beginning Python",
    "section": "",
    "text": "dict.py\n\ncapitals = {\n    \"France\": \"Paris\",\n    \"United Kingdom\": \"London\",\n    \"USA\": \"Washington DC\",\n    \"Kenya\": \"Nairobi\"\n}\n\nfor country, capital in capitals.items():\n    print(\"The capital of\", country, \"is\", capital)\n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\nThe capital of France is Paris\nThe capital of United Kingdom is London\nThe capital of USA is Washington DC\nThe capital of Kenya is Nairobi\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_first_indexing.html",
    "href": "answers/answer_first_indexing.html",
    "title": "Beginning Python",
    "section": "",
    "text": "As well as setting my_element to the “0th” element of the list, we also then create a variable called my_other_element which we fill from the value at index 2:\n\nmy_list = [\"cat\", \"dog\", \"horse\"]\n\nmy_element = my_list[0]\n\nprint(my_element)\n\nmy_other_element = my_list[2]\n\nprint(my_other_element)\n\ncat\nhorse\n\n\nWhen run we see that it prints the zeroth and index-2 elements:\n\n\nTerminal/Command Prompt\n\npython list.py\n\n\n\ncat\nhorse\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_hello_input.html",
    "href": "answers/answer_hello_input.html",
    "title": "Beginning Python",
    "section": "",
    "text": "script.py\n\ngreeting = \"Hello\"\nname = input(\"What is your name? \")\n\nprint(greeting, name)\n\n\n\nTerminal/Command Prompt\n\npython script.py\n\n\n\nWhat is your name? Matt\nHello Matt\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_multiple_print.html",
    "href": "answers/answer_multiple_print.html",
    "title": "Beginning Python",
    "section": "",
    "text": "The variables first_phrase and second_phrase are almost unchanged. The only difference is that first_phrase no longer has the extra space at the end of it.\nWe pass these two variables as two arguments to print(), separating them by commas. print() will automatically add spaces between each argument when displaying the output.\n\n\n\nscript.py\n\ngreeting = \"Hello\"\nname = \"Matt\"\n\nprint(greeting, name)\n\n\nOnce more, when we run our code, the output has not changed, as expected:\n\n\nTerminal/Command Prompt\n\nrun script.py\n\n\n\nHello Matt\n\n\nReturn to course"
  },
  {
    "objectID": "appendix/answer_divide_zero.html",
    "href": "appendix/answer_divide_zero.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Start by deleting all the lines inside the file data.txt.\nWe then edit the end of the script where it calculates the mean so that it only runs if the count is greater than zero:\n\n\n\nfile.py\n\ntotal = 0\ncount = 0\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        number = int(line)\n        total += number\n        count += 1\n\nprint(\"Sum of all\", count, \"values is:\", total)\n\nif count &gt; 0:\n    mean = total / count\n    print(\"The mean is\", mean)\n\n\npython file.py\n\n\nSum of all 0 values is: 0\n\n\nReturn to course"
  },
  {
    "objectID": "appendix/answer_first_read.html",
    "href": "appendix/answer_first_read.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Starting with creating our data file data.txt:\n\n\ndata.txt\n\n12\n54\n7\n332\n54\n1\n0\n\nWe then write a short script to open the data file, loop over its lines and print each in-turn. The only thing that has been changed here is the argument being passed to open():\n\n\n\nfile.py\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        print(line, end=\"\")\n\n\npython file.py\n\n\n12\n54\n7\n332\n54\n1\n0\n\n\nReturn to course"
  },
  {
    "objectID": "appendix/answer_data_sum_count.html",
    "href": "appendix/answer_data_sum_count.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Starting with creating our data file data.txt:\n\n\ndata.txt\n\n12\n54\n7\n332\n54\n1\n0\n\nAs before we start with defining a variable count to start at zero. We increase it by 1 each time around the loop and print it out at the end:\n\n\n\nfile.py\n\ntotal = 0\ncount = 0\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        number = int(line)\n        total += number\n        count += 1\n\nprint(\"Sum of all\", count, \"values is:\", total)\n\n\npython file.py\n\n\nSum of all 7 values is: 460\n\n\nReturn to course"
  },
  {
    "objectID": "appendix/appendix_practice_questions.html",
    "href": "appendix/appendix_practice_questions.html",
    "title": "Beginning Python",
    "section": "",
    "text": "This page contains a number of questions and exercises to give you a chance to practise what you have learned this session.\nYou should create a new .py Python file for each exercise.\n\n\nCreate a list containing 5 different animal types, for example: - cat - dog - elephant - minnow - beaver\nPrint out the list to the screen.\n\n\n\nStart by copying the code that you used to create the list of animals in the last exercise. Write a loop which will print out each of the animals, prefixed with Species:. For example the output could look like:\nSpecies: cat\nSpecies: dog\nSpecies: elephant\nSpecies: minnow\nSpecies: beaver\n\n\n\nCreate a list containing 10 different numbers, ranging from 0 to 100. For example: \\(65, 54, 17, 78, 66, 24, 32, 80, 79, 95\\).\nWrite a loop which will print out only those numbers which are larger than 50.\n\n\n\nCreate a loop which iterates over the numbers from 1 to 20 (inclusive). Inside the loop: - if the number is divisible by three then print “ook”, - if the number is divisible by both three and five then print “foo”, - and if the number is not divisible by either then just print the number.\nHint:  You can use the % operator to find the remainder from a division. Also, take care in the order that you do your if/elif.\n\n\n\nMake a dictionary from the following table of data. The keys of the dictionary should be the names of the paintings and the values should be name of the artist.\n\n\n\nPainting\nArtist\n\n\n\n\nSunflowers\nvan Gogh\n\n\nThe Starry Night\nvan Gogh\n\n\nThe Night Watch\nRembrandt\n\n\nThe Two Fridas\nKahlo\n\n\nBalloon Girl\nBanksy\n\n\nDevolved Parliament\nBanksy\n\n\nGoing to Work\nLowry\n\n\n\nWrite some code which will print out the work of art and the name of the artist if: 1. the artist’s name has an “h” in it, 2. or the name of the artwork is longer than 13 letters.\nHint:  There is an in operator for searching inside strings and a len function for seeing how long something is.\n\n\n\nMake a dictionary of the same information as the last question, but the other way around this time. The key in the dictionary should be the name of the artist, and the value should be a list of names of their paintings.\nWrite some code which will check every painting in the data set. Print out the work of art and the name of the artist if: 1. the artist has more than one painting 2. and the name of the painting has more than one word.\nHint:  Some artists only have one work of art here. Consider putting their single artwork in a single-item list, rather than just as a string.\n\n\n\nCreate a list with some words in it, making sure some words are repeated.\nThe task is to fill up a dictionary so that it contains the count of the number of times each word appears in the list.\nSo, for example if your word list looks like:\nword_list = [\"to\", \"be\", \"or\", \"not\", \"to\", \"be\"]\nthen the output dictionary would look like:\n{\"to\": 2, \"be\": 2, \"or\": 1. \"not\": 1}\nHint:  You can check whether a dictionary already has a particular key in it using the in operator."
  },
  {
    "objectID": "appendix/appendix_practice_questions.html#practice-questions",
    "href": "appendix/appendix_practice_questions.html#practice-questions",
    "title": "Beginning Python",
    "section": "",
    "text": "This page contains a number of questions and exercises to give you a chance to practise what you have learned this session.\nYou should create a new .py Python file for each exercise.\n\n\nCreate a list containing 5 different animal types, for example: - cat - dog - elephant - minnow - beaver\nPrint out the list to the screen.\n\n\n\nStart by copying the code that you used to create the list of animals in the last exercise. Write a loop which will print out each of the animals, prefixed with Species:. For example the output could look like:\nSpecies: cat\nSpecies: dog\nSpecies: elephant\nSpecies: minnow\nSpecies: beaver\n\n\n\nCreate a list containing 10 different numbers, ranging from 0 to 100. For example: \\(65, 54, 17, 78, 66, 24, 32, 80, 79, 95\\).\nWrite a loop which will print out only those numbers which are larger than 50.\n\n\n\nCreate a loop which iterates over the numbers from 1 to 20 (inclusive). Inside the loop: - if the number is divisible by three then print “ook”, - if the number is divisible by both three and five then print “foo”, - and if the number is not divisible by either then just print the number.\nHint:  You can use the % operator to find the remainder from a division. Also, take care in the order that you do your if/elif.\n\n\n\nMake a dictionary from the following table of data. The keys of the dictionary should be the names of the paintings and the values should be name of the artist.\n\n\n\nPainting\nArtist\n\n\n\n\nSunflowers\nvan Gogh\n\n\nThe Starry Night\nvan Gogh\n\n\nThe Night Watch\nRembrandt\n\n\nThe Two Fridas\nKahlo\n\n\nBalloon Girl\nBanksy\n\n\nDevolved Parliament\nBanksy\n\n\nGoing to Work\nLowry\n\n\n\nWrite some code which will print out the work of art and the name of the artist if: 1. the artist’s name has an “h” in it, 2. or the name of the artwork is longer than 13 letters.\nHint:  There is an in operator for searching inside strings and a len function for seeing how long something is.\n\n\n\nMake a dictionary of the same information as the last question, but the other way around this time. The key in the dictionary should be the name of the artist, and the value should be a list of names of their paintings.\nWrite some code which will check every painting in the data set. Print out the work of art and the name of the artist if: 1. the artist has more than one painting 2. and the name of the painting has more than one word.\nHint:  Some artists only have one work of art here. Consider putting their single artwork in a single-item list, rather than just as a string.\n\n\n\nCreate a list with some words in it, making sure some words are repeated.\nThe task is to fill up a dictionary so that it contains the count of the number of times each word appears in the list.\nSo, for example if your word list looks like:\nword_list = [\"to\", \"be\", \"or\", \"not\", \"to\", \"be\"]\nthen the output dictionary would look like:\n{\"to\": 2, \"be\": 2, \"or\": 1. \"not\": 1}\nHint:  You can check whether a dictionary already has a particular key in it using the in operator."
  },
  {
    "objectID": "appendix/answer_multiply_data.html",
    "href": "appendix/answer_multiply_data.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Starting with creating our data file data.txt:\n\n\ndata.txt\n\n12\n54\n7\n332\n54\n1\n0\n\nWe have changed just one line so that it now has * 10 rather than + 17:\n\n\n\nfile.py\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        number = int(line)\n        new_number = number * 10\n        print(new_number)\n\n\npython file.py\n\n\n120\n540\n70\n3320\n540\n10\n0\n\n\nReturn to course"
  },
  {
    "objectID": "appendix/appendix_files.html",
    "href": "appendix/appendix_files.html",
    "title": "Files",
    "section": "",
    "text": "Everything we’ve done so far has been completely self-contained in the script and every time we run any of them we will get exactly the same output. The power of programming is to be able to take the same piece of code and apply it to different data to get different results. One common way in which this is done is writing a script which can analyse a data file. To do that we need to learn how to open files.\nThe simplest this we can do with files is read a file in and print it to the screen. Make a new script called file.py and put the following in it:\n\n\n\nfile.py\n\nwith open(\"file.py\") as f:\n    for line in f:\n        print(line, end=\"\")\n\n\nWhen you run it, you will see the following:\npython file.py\n\n\nwith open(\"file.py\") as f:\n    for line in f:\n        print(line, end=\"\")\n\n\nwhich is (somewhat recursively) the contents of the file file.py.\nThere are a few new things here so let’s go through them in turn. The first thing is to open the file. You open files using the open function. The part open(\"file.py\") says to open the file file.py. This returns a file handle which is assigned to the variable f. If the file does not exist, or is not readable then the script will exit with an error (have a try and see what the error looks like!). The use of a with statement means that when the code inside the with block has finished running the file will be closed automatically.\nIn the next line (for line in f:) we are looping over the lines of the file. This loop looks just like those we used when looping over lists a few chapters previously. When looping over a list you get each of the elements in turn but when looping over an open file you get each of the lines in turn. We assign the string containing the line from the file to the variable line.\nFinally, we print the string line. Each line in the file already ends with a “new-line” character so when it is printed, it will print the new-line too. By default the print function will also add its own new-line so we disable that by using end=\"\".\n\n\n\n\n\n\nExercise 1\n\n\n\n\nPrinting out Python code isn’t the most useful so let’s make a data file to read instead. Make a new file called data.txt and put inside it:\n12\n54\n7\n332\n54\n1\n0\n\nEdit file.py so that it prints out the contents of data.txt instead. answer\n\n\n\n\nData type conversion\nSimply reading the data and printing it isn’t very useful. Let’s take a first step towards some data analysis and pretend that the task we’re trying to do is to read in data from the file and add 17 to each value.\n\n\n\nfile.py\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        new_number = line + 17  # Here is where we do our \"data analysis\"\n        print(new_number, end=\"\")\n\n\nIf you edit file.py to contain this code and run it you should see an error:\nTraceback (most recent call last):\n  File \"file.py\", line 3, in &lt;module&gt;\n    new_number = line + 17\nTypeError: can only concatenate str (not \"int\") to str\nThis is telling us that there is an error occuring when trying to add 17 to the data read in from the line in the file. The type of the error is TypeError which tells us the problem is likely due to incorrect data types (i.e. string, float, int, list etc.). The error message says can only concatenate str (not \"int\") to str which implies that the computer believes that we’re trying to concatenate (join together) something with a string. The only two things involved in this operation are line and 17. We know that 17 is an integer so line must be a string!\nWhen reading from a file like this, everything it gives you will always be a string, even if the string only contains digits like \"12\". If we know that the file only contains integers then we can convert each number as it comes in using the int function. Also, since we’re now printing integers, we no longer need the end=\"\" tweak:\n\n\n\nfile.py\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        number = int(line)  # Here we do the type conversion\n        new_number = number + 17  # Here is where we do our \"data analysis\"\n        print(new_number)\n\n\nRunning this new script will now print out our “processed” data:\npython file.py\n\n\n29\n71\n24\n349\n71\n18\n17\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\n\nChange file.py to multiply the data by 10 instead of adding 17. answer\nAfter looping though the data, print out the sum of all the data values seen.\n\nhint: Make an integer before the loop, initially set to zero and add to it each time around the loop\nhint: You can increase an integer by an amount using += like:\nnum = 3\nnum += 4\nprint(num)  # `num` will now be 7\nanswer\n\nPrint out the count of the number of data points seen as well. answer\nPrint out the mean average of the data in the file. answer\nSee what happens if you run the script after deleting the contents of data.txt. Add an if statement to fix it. answer\nCollect the statistics into a summary dictionary with keys \"sum\", \"count\" and \"mean\". answer\n\n\n\nReturn to summary"
  },
  {
    "objectID": "appendix/answer_data_sum.html",
    "href": "appendix/answer_data_sum.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Starting with creating our data file data.txt:\n\n\ndata.txt\n\n12\n54\n7\n332\n54\n1\n0\n\nWe start by defining an integer, total to be zero before the loop. Inside the loop we add the line of code total += number which increases the variable total by the value in the variable number.\nFinally we print the total:\n\n\n\nfile.py\n\ntotal = 0\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        number = int(line)\n        total += number\n\nprint(\"Sum of all values is:\", total)\n\n\npython file.py\n\n\nSum of all values is: 460\n\n\nReturn to course"
  },
  {
    "objectID": "appendix/answer_data_mean.html",
    "href": "appendix/answer_data_mean.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Starting with creating our data file data.txt:\n\n\ndata.txt\n\n12\n54\n7\n332\n54\n1\n0\n\nHere the loop itself has not changed, we’ve just created a new variable afterwards, mean which is calculated from total and count:\n\n\n\nfile.py\n\ntotal = 0\ncount = 0\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        number = int(line)\n        total += number\n        count += 1\n\nmean = total / count\n\nprint(\"Sum of all\", count, \"values is:\", total)\nprint(\"The mean is\", mean)\n\n\npython file.py\n\n\nSum of all 7 values is: 460\nThe mean is 65.71428571428571\n\n\nReturn to course"
  },
  {
    "objectID": "appendix/answer_data_summary_dict.html",
    "href": "appendix/answer_data_summary_dict.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Starting with creating our data file data.txt:\n\n\ndata.txt\n\n12\n54\n7\n332\n54\n1\n0\n\nThe logic in this script is identical but instead of having total, count and mean as separate variables, we have collected them into a single dictionary:\n\n\n\nfile.py\n\nstats = {\"sum\": 0, \"count\": 0}\n\nwith open(\"data.txt\") as f:\n    for line in f:\n        number = int(line)\n        stats[\"sum\"] += number\n        stats[\"count\"] += 1\n\nif stats[\"count\"] &gt; 0:\n    stats[\"mean\"] = stats[\"sum\"] / stats[\"count\"]\n\nprint(stats)\n\n\npython file.py\n\n\n\nfile.py\n\nstats = {\"sum\": 0, \"count\": 0}\n\nwith open(\"../data/data.txt\") as f:\n    for line in f:\n        number = int(line)\n        stats[\"sum\"] += number\n        stats[\"count\"] += 1\n\nif stats[\"count\"] &gt; 0:\n    stats[\"mean\"] = stats[\"sum\"] / stats[\"count\"]\n\nprint(stats)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Python is a programming language which allows us to give instructions to the computer. These instructions can be as simple as “add together these two numbers” or as complex as “give me the average CO2 concentration for 2020”. For the former we will be able to complete the task using only a single instruction but for the latter, we may have to write a larger program containing hundreds or thousands of instructions.\nThis course is going to start from the beginning, showing you to talk to the computer to perform simple tasks and as you become more confident and follow the later courses, you will find that you are able to write much more complex programmes.\nPython is a well-established language, with the current version (version 3) released in 2008 and it is installed by default on nearly all modern Linux systems. Python is also available for MacOS and Windows.\nThis workshop is going to introduce you to the basics of the Python programming language with more advanced topics being covered by later workshops.\nYou can jump ahead to any chapter:\n\nGetting started\nData types\nLists\nLoops\nConditionals\nDictionaries\nSummary\n\n\nSetting up your workspace\nThere are lots of different ways to run Python code and many tools to help you write it. You don’t require any special tools to create a Python script, a simple text editor like Notepad on Windows is sufficient. More advanced tools include things like Jupyter Notebooks and IDEs like PyCharm or Visual Studio Code.\nFor this workshop we will be keeping things as simple as possible in order to allow us to focus on the topics we’re learning without having to learn too many extra tools along the way.\nFor the purpose of this course we will be using a free tool called JupyterLab which provides you with a local editor in your web browser where you can write and run Python code. The easiest way to get access to JupyterLab is to install Anaconda which is a piece of software which includes Python along with lots of other tools. It is freely available for Windows, MacOS and Linux.\nAnaconda can be installed into your home area on your computer so if you are on a work laptop, for example, you will not need any special permissions. Once Anaconda is installed, start “Anaconda Navigator” and press the JupyterLab button on the main screen:\n\n\n\nAnaconda Navigator\n\n\nThis will open JupyterLab in your default web browser and will look something like this:\n\n\n\nJupyterLab\n\n\nThe way that we will be setting up the space is to have a text editor on the left-hand side of the screen and a terminal on the right hand side. We’ll use the editor to write our code and the terminal to run it.\nIn the launcher tab, scoll down to the “Text File” entry and click that. It will turn the editor into a text editor. Then go to File → New and select “Terminal”. It will now have two tabs inside the interface, one labelled “untitled.txt” and the other labelled “Terminal 1”:\n\n\n\nJupyterLab\n\n\nThe contents of the Terminal tab will likely be a little different on your computer, compared to what is shown in thise images but that is ok.\nTo make our lives easier, let’s rearange things so that we can see the text editor at the same time as the terminal. Do this by pressing and holding down the left mouse button on the tab that says “Terminal 1” and slowly dragging it to the right-hand side of the window. You’ll see a blue outline like this:\n\n\n\nJupyterLab\n\n\nRelease the mouse button and you’ll end up with the two showing side-by-side:\n\n\n\nJupyterLab\n\n\nWe’re now ready to get started!",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "answers/answer_loop_floats_enumerate.html",
    "href": "answers/answer_loop_floats_enumerate.html",
    "title": "Beginning Python",
    "section": "",
    "text": "loop.py\n\nmy_numbers = [4.5, 3.7, 8.9, 2.3, 3.14159, 4.0]\n\nfor index, value in enumerate(my_numbers):\n    print(index, \":\", value) \n\n\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\n0 : 4.5\n1 : 3.7\n2 : 8.9\n3 : 2.3\n4 : 3.14159\n5 : 4.0\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_first_dictionary.html",
    "href": "answers/answer_first_dictionary.html",
    "title": "Beginning Python",
    "section": "",
    "text": "dict.py\n\nsounds = {\"cat\": \"meow\", \"dog\": \"woof\", \"horse\": \"neigh\"}\n\ndog_sound = sounds[\"dog\"]\nhorse_sound = sounds[\"horse\"]\n\nprint(\"Dog goes\", dog_sound)\nprint(\"Horse goes\", horse_sound)\n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\nDog goes woof\nHorse goes neigh\n\n\nIf we edit our script so that it asks for a key that doesn’t exist, we will see an error being produced:\n\n\n\ndict.py\n\nsounds = {\"cat\": \"meow\", \"dog\": \"woof\", \"horse\": \"neigh\"}\n\nfish_sound = sounds[\"fish\"]\n\nprint(fish_sound)\n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n---------------------------------------------------------------------------\n\nKeyError                                  Traceback (most recent call last)\n\n~/courses/beginning_python/dict.py in &lt;module&gt;\n      2 sounds = {\"cat\": \"meow\", \"dog\": \"woof\", \"horse\": \"neigh\"}\n      3 \n----&gt; 4 fish_sound = sounds[\"fish\"]\n      5 \n      6 print(fish_sound)\n\n\nKeyError: 'fish'\nReturn to course"
  },
  {
    "objectID": "answers/answer_calculator.html",
    "href": "answers/answer_calculator.html",
    "title": "Beginning Python",
    "section": "",
    "text": "calc.py could look like:\n\n\n\ncalc.py\n\ncalculation = input(\"&gt; \")\n\nparts = calculation.split()  # Split e.g. \"4 * 6\" into [\"4\", \"*\", \"6\"]\nlhs = int(parts[0])  # Extract e.g. \"4\" and turn it into 4\noperation = parts[1]  # Extract e.g. \"*\"\nrhs = int(parts[2])  # Extract e.g. \"6\" and turn it into 6\n\nif operation == \"+\":\n    print(calculation, \"is\", lhs + rhs)\nelif operation == \"-\":\n    print(calculation, \"is\", lhs - rhs)\nelif operation == \"*\":\n    print(calculation, \"is\", lhs * rhs)\nelif operation == \"/\":\n    print(calculation, \"is\", lhs / rhs)\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 4 * 6\n4 * 6 is 24\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 5 + 6\n5 + 6 is 11\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 457 - 75\n457 - 75 is 382\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 54 / 3\n54 / 3 is 18.0\n\n\n\nPossible improvements\nThe code above works fine, but there’s always more than one way to approach a problem like this.\n\nSeparating calculation from output\nOne thing that we could improve would be the repetition in the print lines. Each of them are almost the same as each other and if we wanted to change the output from\n4 * 6 is 24\nto something like\n4 * 6 = 24\nthen we’d have to edit all four lines of code.\nRemembering our three-part pattern from earlier in the course of input→calculation→output, it’s a good idea to split out the calculation of data from the printing and display of data. In our case we could change it to look like:\n\n\n\ncalc.py\n\ncalculation = input(\"&gt; \")\n\n# Prepare the parts\nparts = calculation.split()\nlhs = int(parts[0])\noperation = parts[1]\nrhs = int(parts[2])\n\n# Calculate the answer\nif operation == \"+\":\n    result = lhs + rhs\nelif operation == \"-\":\n    result = lhs - rhs\nelif operation == \"*\":\n    result = lhs * rhs\nelif operation == \"/\":\n    result = lhs / rhs\n\n# Output the result\nprint(calculation, \"is\", result)\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 4 * 6\n4 * 6 is 24\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 5 + 6\n5 + 6 is 11\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 457 - 75\n457 - 75 is 382\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 54 / 3\n54 / 3 is 18.0\n\n\n\n\n\nAdvanced: Using the operator module\nWe haven’t covered using extra modules in this course so far, but you might have come across these if you’ve done some Python before. We cover this in more detail in the Intermediate Python chapter Using Functions. I’m showing you this way to solve the problem, not because I expect you to able to do this already, but so that when you look back at these notes in the future you see how you might solve the problem differently.\n\n\n\ncalc.py\n\nimport operator\n\n# Make a dictioanry that maps from\n# the operator string passed in and\n# a function which does the operation\noperators = {\n    \"+\": operator.add,\n    \"-\": operator.sub,\n    \"*\": operator.mul,\n    \"/\": operator.truediv,\n}\n\ncalculation = input(\"&gt; \")\n\n# Prepare the parts\nparts = calculation.split()\nlhs = int(parts[0])\noperation = parts[1]\nrhs = int(parts[2])\n\n# We extract the operator function from the operators dictionary\n# allowing us to then call the function with the round brackets\nresult = operators[operation](lhs, rhs)\n\n# Output the result\nprint(calculation, \"is\", result)\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 4 * 6\n4 * 6 is 24\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 5 + 6\n5 + 6 is 11\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 457 - 75\n457 - 75 is 382\n\n\n\n\nTerminal/Command Prompt\n\npython calc.py\n\n\n\n&gt; 54 / 3\n54 / 3 is 18.0\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_more_conditionals.html",
    "href": "answers/answer_more_conditionals.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Less than:\n\n\n\nif.py\n\nmy_number = int(input(\"Enter a number: \"))  # We can nest function calls directly\n\nif my_number &lt; 100:\n    print(my_number, \"is less than 100\")\n\n\n\n\nTerminal/Command Prompt\n\npython if.py\n\n\n\nEnter a number:  74\n74 is less than 100\n\n\n\nEqual to:\n\n\n\nif.py\n\nmy_number = int(input(\"Enter a number: \"))  # We can nest function calls directly\n\nif my_number == 100:\n    print(my_number, \"== 100\")\nif my_number == 74:\n    print(my_number, \"== 74\")\n\n\n\n\nTerminal/Command Prompt\n\npython if.py\n\n\n\nEnter a number:  74\n74 == 74\n\n\n\nNot equal to:\n\n\n\nif.py\n\nmy_number = int(input(\"Enter a number: \"))  # We can nest function calls directly\n\nif my_number != 100:\n    print(my_number, \"!= 100\")\n\nif my_number != 74:\n    print(my_number, \"!= 74\")\n\n\n\n\nTerminal/Command Prompt\n\npython if.py\n\n\n\nEnter a number:  74\n74 != 100\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_add_to_dictionary.html",
    "href": "answers/answer_add_to_dictionary.html",
    "title": "Beginning Python",
    "section": "",
    "text": "dict.py\n\nsounds = {\"cat\": \"meow\", \"dog\": \"woof\"}\n\nsounds[\"horse\"] = \"neigh\"\nsounds[\"cow\"] = \"moo\"\n\nprint(sounds)\n\n\n\n\nTerminal/Command Prompt\n\npython dict.py\n\n\n\n{'cat': 'meow', 'dog': 'woof', 'horse': 'neigh', 'cow': 'moo'}\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_two_line_print.html",
    "href": "answers/answer_two_line_print.html",
    "title": "Beginning Python",
    "section": "",
    "text": "We have moved the string out of the parentheses and into a named variable, words. We then pass this variable to the function:\n\n\n\nscript.py\n\nwords = \"Hello Matt\"\n\nprint(words)\n\n\nWhen we run our script we see that the output has not changed, as expected:\n\n\nTerminal/Command Prompt\n\npython script.py\n\n\n\nHello Matt\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_first_loop.html",
    "href": "answers/answer_first_loop.html",
    "title": "Beginning Python",
    "section": "",
    "text": "Adding more items to the list makes the loop go around more times:\n\n\n\nloop.py\n\nmy_words = [\"Hello\", \"Python\", \"Goodbye\", \"Python\"]\n\nfor word in my_words:\n    print(word)\n\n\npython loop.py\n\n\nHello\nPython\nGoodbye\nPython\n\n\nA list with a mixture of data types can be printed witout issue:\n\n\n\nloop.py\n\nmy_words = [\"Hello\", \"Python\", 404, \"Goodbye\", \"Python\", 42]\n\nfor word in my_words:\n    print(word)\n\n\npython loop.py\n\n\nHello\nPython\n404\nGoodbye\nPython\n42\n\n\nLooping over an empty list does not print anything:\n\n\n\nloop.py\n\nmy_words = []\n\nfor word in my_words:\n    print(word)\n\n\npython loop.py\nReturn to course"
  },
  {
    "objectID": "answers/answer_first_if.html",
    "href": "answers/answer_first_if.html",
    "title": "Beginning Python",
    "section": "",
    "text": "if.py\n\nmy_number = int(input(\"Enter a number: \"))  # We can nest function calls directly\n\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\n\nIf my_number is smaller than 100 then the expression is false and so the if does not trigger and nothing is printed:\n\n\nTerminal/Command Prompt\n\npython if.py\n\n\n\nEnter a number:  42\n\n\nReturn to course"
  },
  {
    "objectID": "answers/answer_add_strings.html",
    "href": "answers/answer_add_strings.html",
    "title": "Beginning Python",
    "section": "",
    "text": "We make two strings. One called first_phrase and second called second_phrase. We then make a third variable called message by adding together (using the + symbol) the other two. This combines the strings together into a new, longer string:\n\n\n\nscript.py\n\nfirst_phrase = \"The Battle of Hastings \"\nsecond_phrase = \"was in 1066\"\n\nmessage = first_phrase + second_phrase\n\nprint(message)\n\n\nAgain, when we run our code, the output has not changed, as expected:\n\n\nTerminal/Command Prompt\n\nrun script.py\n\n\n\nThe Battle of Hastings was in 1066\n\n\nReturn to course"
  },
  {
    "objectID": "pages/02-data-types.html",
    "href": "pages/02-data-types.html",
    "title": "Data Types",
    "section": "",
    "text": "In the last chapter we introduced the idea of “strings”. They are a way of representing normal human words inside a Python script. Strings start and end with double quotes (\") e.g.,\n\n\"Hello from Python!\"\n\nis a string with three words and an exclamation mark as content.\nStrings can contain numbers as well:\n\n\"The Battle of Hastings was in 1066\"\n\nand they can even be empty:\n\n\"\"\n\nIt is possible in Python to also use single quotes (') to make strings, as long as the string starts and ends with the same type of quote, but it is convention to prefer double quotes.\n\n\n\n\n\n\nExercise 1\n\n\n\nEdit the file script.py to print out your name so that when it’s run it shows something like:\nHello Matt\nanswer\n\n\n\n\nThe other most common type of data that you’ll find in Python scripts are numbers. There are two main types of number in Python:\n\nFloats (or floating point numbers) are a way of representing numbers with decimal places\nIntegers are for representing whole numbers\n\nWhen creating numbers in Python, you do not use quotes, you write the number directly. So:\n\n3.14159\n\nis a float and\n\n42\n\nis an integer.\nIt’s important that when writing numbers in your scripts, you do not put quotation marks around them. There is a difference between 42 and \"42\". The first is the integer \\(42\\) (i.e. the number one greater that \\(41\\)) and the second is just a pair of digits and has no more meaning to Python than \"fourty two\" or \"penguin\" do.\n\n\n\nOf course, it not much use to have numbers and strings floating about with no connection to each other. We want to be able to give them names and combine them together. We assign names to data using the = sign. For example if we want to make some data and give it a name we can do it like:\n\npi = 3.14159\n\nThis has created a number 3.14159 and given it a name, pi. We can now use this name in other parts of the program to refer to that piece of data:\n\nprint(pi)\n\nNames in Python can contain upper and lower case letters, numbers and underscores (but can’t start with a number). Chosing the correct name for a particular variable is an important task as a non-descriptive name (or worse, an incorrect name) will be very confusing for you and anyone reading your code. It is common in Python to name your variables with all lower case letters and use underscores to separate words.\nSo, for a variable which contains a number representing a distance in miles, avoid shortened names like dm, distm or d and instead use a name like distance_in_miles. Remember, code will be written once but read many times so make it easy to read.\nThese two can be combined into a full Python script:\n\n\n\nvariables.py\n\npi = 3.14159\nprint(pi)\n\n\nand run with:\n\n\nTerminal/Command Prompt\n\npython variables.py\n\n\n\n3.14159\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nEdit your script.py to split it over two lines. The first line should create a string and give it a variable name and the second line should use that name to print. Make sure you save the file and rerun it in the terminal.\nanswer\n\n\n\n\n\nVariables are more that just a way of labelling data, they also make it easier to do things with your data. If you have some numbers you can add, subtract, multiply and divide them as you would expect. The symbol for multiplication is * and the symbol for division is /.\n\ndistance_in_miles = 30\ndistance_in_km = distance_in_miles * 1.60934\n\nprint(distance_in_km)\n\nHere we created a variable distance_in_miles with the value of 30. Then we used that variable in line two and multiplied it by a number (distance_in_miles * 1.60934) and assigned the result of that calculation to a new variable called distance_in_km. Finally, we printed out the new variable.\nLikewise we can do addition:\n\ntemperature_in_celcius = 25.1\ntemperature_in_kelvin = temperature_in_celcius + 273.15\n\nprint(temperature_in_kelvin)\n\n\n\n\nSo far we’ve been giving the print function a single argument to print a single thing but we can print many things at once if we give it multiple arguments. Arguments to functions in Python are separated by commas. The print function is designed so that it will print each of the arguments it was provided with, one after another on the same line, separated by spaces.\n\n\n\ncolour.py\n\nfav = \"red\"\nprint(\"My favourite colour is\", fav)\n\n\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nMy favourite colour is red\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nEdit script.py so that the two parts of the phrase are passed to print as separate arguments. Make sure you save the file and rerun it in the terminal.\nIf you get strange output like ('Hello', 'Python') rather than Hello Python, then try running your script with the python3 command as described in this video.\nanswer\n\n\n\n\n\nSo far, all the code we’ve run is somewhat static. Every time we run the script, the output will always be the same. What if your favourite colour is not red? The power of programming is that it is dynamic and we can write code which responds and reacts. We’ll see a lot more of this throughout this workshop, but for now we’ll introduce one more function that Python provides, input.\nThe print function is how we get information out of our program, and the input function is how we get data into it.\nThe input function will pause the program and wait for you to type something in. Whatever you type, followed by enter will be assigned to whatever variable name you put on the left hand side of the =.\n\n\ncolour.py\n\nprint(\"What is your favourite colour?\")\n\nfav = input()\n\nprint(\"My favourite colour is\", fav)\n\nNow, if we run this script, it will print the first message, and then wait for you to type something. If you type “red” and then press enter, it will assign “red” to the variable fav and then use that variable in the final print function:\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nWhat is your favourite colour?\nred\nMy favourite colour is red\n\n\nLikewise, you can run the script one more time and give a different answer and get a different output:\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nWhat is your favourite colour?\ngreen\nMy favourite colour is green\n\n\n\n\nOne small improvement we can make is that instead of printing our message “What is your favourite colour?”, prompting the user of the script to type something, we can do this directly with the input function by giving the prompt as an argument:\n\n\ncolour.py\n\nfav = input(\"What is your favourite colour?\")\n\nprint(\"My favourite colour is\", fav)\n\nNote that there is a space after the question mark so that when you’re typing in your answer it’s not butting directly against the character:\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nWhat is your favourite colour? red\nMy favourite colour is red\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nEdit script.py so the value of the variable name is set using the input function. Be sure to set a prompt as well so that the user know that they should type something.\nThe script should, when run with python script.py, then print out:\nWhat is your name?\nand wait for you to type your name like:\nWhat is your name? Matt\nAfter pressing enter, it should then print out:\nWhat is your name? Matt\nHello Matt\nanswer",
    "crumbs": [
      "Data Types"
    ]
  },
  {
    "objectID": "pages/02-data-types.html#strings",
    "href": "pages/02-data-types.html#strings",
    "title": "Data Types",
    "section": "",
    "text": "In the last chapter we introduced the idea of “strings”. They are a way of representing normal human words inside a Python script. Strings start and end with double quotes (\") e.g.,\n\n\"Hello from Python!\"\n\nis a string with three words and an exclamation mark as content.\nStrings can contain numbers as well:\n\n\"The Battle of Hastings was in 1066\"\n\nand they can even be empty:\n\n\"\"\n\nIt is possible in Python to also use single quotes (') to make strings, as long as the string starts and ends with the same type of quote, but it is convention to prefer double quotes.\n\n\n\n\n\n\nExercise 1\n\n\n\nEdit the file script.py to print out your name so that when it’s run it shows something like:\nHello Matt\nanswer\n\n\n\n\nThe other most common type of data that you’ll find in Python scripts are numbers. There are two main types of number in Python:\n\nFloats (or floating point numbers) are a way of representing numbers with decimal places\nIntegers are for representing whole numbers\n\nWhen creating numbers in Python, you do not use quotes, you write the number directly. So:\n\n3.14159\n\nis a float and\n\n42\n\nis an integer.\nIt’s important that when writing numbers in your scripts, you do not put quotation marks around them. There is a difference between 42 and \"42\". The first is the integer \\(42\\) (i.e. the number one greater that \\(41\\)) and the second is just a pair of digits and has no more meaning to Python than \"fourty two\" or \"penguin\" do.\n\n\n\nOf course, it not much use to have numbers and strings floating about with no connection to each other. We want to be able to give them names and combine them together. We assign names to data using the = sign. For example if we want to make some data and give it a name we can do it like:\n\npi = 3.14159\n\nThis has created a number 3.14159 and given it a name, pi. We can now use this name in other parts of the program to refer to that piece of data:\n\nprint(pi)\n\nNames in Python can contain upper and lower case letters, numbers and underscores (but can’t start with a number). Chosing the correct name for a particular variable is an important task as a non-descriptive name (or worse, an incorrect name) will be very confusing for you and anyone reading your code. It is common in Python to name your variables with all lower case letters and use underscores to separate words.\nSo, for a variable which contains a number representing a distance in miles, avoid shortened names like dm, distm or d and instead use a name like distance_in_miles. Remember, code will be written once but read many times so make it easy to read.\nThese two can be combined into a full Python script:\n\n\n\nvariables.py\n\npi = 3.14159\nprint(pi)\n\n\nand run with:\n\n\nTerminal/Command Prompt\n\npython variables.py\n\n\n\n3.14159\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nEdit your script.py to split it over two lines. The first line should create a string and give it a variable name and the second line should use that name to print. Make sure you save the file and rerun it in the terminal.\nanswer\n\n\n\n\n\nVariables are more that just a way of labelling data, they also make it easier to do things with your data. If you have some numbers you can add, subtract, multiply and divide them as you would expect. The symbol for multiplication is * and the symbol for division is /.\n\ndistance_in_miles = 30\ndistance_in_km = distance_in_miles * 1.60934\n\nprint(distance_in_km)\n\nHere we created a variable distance_in_miles with the value of 30. Then we used that variable in line two and multiplied it by a number (distance_in_miles * 1.60934) and assigned the result of that calculation to a new variable called distance_in_km. Finally, we printed out the new variable.\nLikewise we can do addition:\n\ntemperature_in_celcius = 25.1\ntemperature_in_kelvin = temperature_in_celcius + 273.15\n\nprint(temperature_in_kelvin)\n\n\n\n\nSo far we’ve been giving the print function a single argument to print a single thing but we can print many things at once if we give it multiple arguments. Arguments to functions in Python are separated by commas. The print function is designed so that it will print each of the arguments it was provided with, one after another on the same line, separated by spaces.\n\n\n\ncolour.py\n\nfav = \"red\"\nprint(\"My favourite colour is\", fav)\n\n\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nMy favourite colour is red\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nEdit script.py so that the two parts of the phrase are passed to print as separate arguments. Make sure you save the file and rerun it in the terminal.\nIf you get strange output like ('Hello', 'Python') rather than Hello Python, then try running your script with the python3 command as described in this video.\nanswer\n\n\n\n\n\nSo far, all the code we’ve run is somewhat static. Every time we run the script, the output will always be the same. What if your favourite colour is not red? The power of programming is that it is dynamic and we can write code which responds and reacts. We’ll see a lot more of this throughout this workshop, but for now we’ll introduce one more function that Python provides, input.\nThe print function is how we get information out of our program, and the input function is how we get data into it.\nThe input function will pause the program and wait for you to type something in. Whatever you type, followed by enter will be assigned to whatever variable name you put on the left hand side of the =.\n\n\ncolour.py\n\nprint(\"What is your favourite colour?\")\n\nfav = input()\n\nprint(\"My favourite colour is\", fav)\n\nNow, if we run this script, it will print the first message, and then wait for you to type something. If you type “red” and then press enter, it will assign “red” to the variable fav and then use that variable in the final print function:\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nWhat is your favourite colour?\nred\nMy favourite colour is red\n\n\nLikewise, you can run the script one more time and give a different answer and get a different output:\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nWhat is your favourite colour?\ngreen\nMy favourite colour is green\n\n\n\n\nOne small improvement we can make is that instead of printing our message “What is your favourite colour?”, prompting the user of the script to type something, we can do this directly with the input function by giving the prompt as an argument:\n\n\ncolour.py\n\nfav = input(\"What is your favourite colour?\")\n\nprint(\"My favourite colour is\", fav)\n\nNote that there is a space after the question mark so that when you’re typing in your answer it’s not butting directly against the character:\n\n\nTerminal/Command Prompt\n\npython colour.py\n\n\n\nWhat is your favourite colour? red\nMy favourite colour is red\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nEdit script.py so the value of the variable name is set using the input function. Be sure to set a prompt as well so that the user know that they should type something.\nThe script should, when run with python script.py, then print out:\nWhat is your name?\nand wait for you to type your name like:\nWhat is your name? Matt\nAfter pressing enter, it should then print out:\nWhat is your name? Matt\nHello Matt\nanswer",
    "crumbs": [
      "Data Types"
    ]
  },
  {
    "objectID": "pages/04-loops.html",
    "href": "pages/04-loops.html",
    "title": "Loops",
    "section": "",
    "text": "In the introduction you were told that Python will read your script, starting at the top and running each line of code until it reaches the bottom. While largely true, it is possible to make Python repeat certain lines of code using loops.\nThe ability to run a line of code multiple times is the first large step on your road to making your code reusable.\nImagine we have two strings that we want to print. We could start by making a variable containing one of the words and then printing it:\n\nword = \"Hello\"\n\nprint(word)\n\nHello\n\n\nTo print our second word, we could copy and paste those two lines to create a program which can print both words:\n\n\n\nloop.py\n\nword = \"Hello\"\n\nprint(word)\n\nword = \"Python\"\n\nprint(word)\n\n\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\nHello\nPython\n\n\nThis printed the output we want. But we can see that this code is wasteful as the two print lines are identical to each other. They both print whatever the variable word is pointing at. If we can manage to write that line only once then we could save ourselves some typing!\nLet’s start by making a container for our words. A Python list makes sense:\n\nmy_words = [\"Hello\", \"Python\"]\n\nwe can now write a loop which will perform a task once for each word in our list:\n\n\n\nloop.py\n\nmy_words = [\"Hello\", \"Python\"]\n\nfor word in my_words:\n    print(word)\n\n\nNow, when we run it, we should see that it prints the same output as our previous example.\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\nHello\nPython\n\n\nWe’ve taken a script that was four lines of code and have reduced it to three lines. That might not seem like much of a reduction but the loop we wrote will work no matter how many items there are in the list my_words.\nMost loops in Python work by doing some set of actions for each item in the list. For this reason, this sort of loop is sometimes called a for-each loop.\nThis maps to real life where you may want, for example, to buy each item on your shopping list. Another way of saying that could be “for each item on my shopping list, buy the item”, or as you would write that in Python:\nfor item in shopping_list:\n    buy(item)\n\n\n\n\n\n\nExercise 1\n\n\n\nEdit loop.py to have a different number of words in the list. - Does it work if you put numbers (i.e. integers or floats) in there as well? - What happens if the list my_words is empty? - hint: empty lists look like []\nanswer\n\n\n\nLoop syntax breakdown\nBefore we move on to other things we can do with loops, let’s first make sure that we understand what’s happening on those two lines of Python code that make up the loop.\nThe first line is where most of the magic is hapenning and I like to break it down into five sections, three of fixed scaffolding and two where you as a programmer can have input.\nThe scaffolding is the parts of the line which must always be the same and which Python uses to know that you’re trying to make a loop. They’re pointed out here as the word for, the word in and the colon (:) at the end of the line. These must always be there and in that order:\n ↓        ↓         ↓\nfor word in my_words:\n    print(word)\n\nOnce the scaffolding is in place, you can place between it the things that you care about. the first thing to think about is the object that you want to loop over. In our case we want to loop over the list my_words because we want to perform some action on every item in that list (we want to print the item):\n                ↓\nfor word in my_words:\n    print(word)\n\nNow we have decided what object we are looping over, we need to decide what name we want to give temporarily to each item as we get to it. As with any variable naming, it is important that we choose a good name which describe a single object from the list. For example, if we’re looping over all students in a class then we could call the variable student or if we’re looping over a list of ages then we could call the variable age. The actual choice of variable name here does not affect how the code runs. We could use the name sausage and the code would run identically.\nHere, since we’re looping over a list of generic words, we name our variable word:\n      ↓\nfor word in my_words:\n    print(word)\n\nThat’s all that’s required to tell Python that we’re making a loop but if we want the loop to actually do something then we need to give the loop a body. The body is the lines of code that are going to be repeated. They can be any Python code but it is only within the body of the loop that we can refer to the loop variable word:\nfor word in my_words:\n    print(word)       ← body of loop\n\nFinally, we get to a peculiarity of Python in that it uses indentation to decide what is in the body of the loop and what is not. Remember that it will only repeat the code in the body. All code in the body must be indented relative to the word for by four spaces. A trick to help remember this is that every time you see a colon in Python you should start a new line and indent:\n                  colon\n                    ↓\nfor word in my_words:\n    print(word)\n  ↑\nindentation\n\nIf we want to write code after the end of a loop, we have to make sure that it is not indented. So this code:\n\n\n\nloop.py\n\nmy_words = [\"Hello\", \"Python\"]\n\nfor word in my_words:\n    print(word)\n\nprint(\"...Goodbye\")\n\n\nwill print:\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\nHello\nPython\n...Goodbye\n\n\nbut this code:\n\n\nloop.py\n\n#| filename: loop.py\n#| output: false\nmy_words = [\"Hello\", \"Python\"]\n\nfor word in my_words:\n    print(word)\n\n    print(\"...Goodbye\")\n\nwill print:\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\nHello\n...Goodbye\nPython\n...Goodbye\n\n\nSee how the ...Goodbye was repeated in the second example, this is because it was inside the body of the loop since it was indented.\n\n\nExtended: What can we loop over\nA lot of the power of loops comes from being able to put a lot of different things in the place of my_words.\nMost simply, instead of putting a variable name there, you can put a list directly:\n\n\n\nloop.py\n\nfor word in [\"Hello\", \"Python\"]:\n    print(word)\n\n\nAs well as lists we can put anything which Python considers iterable. For now we haven’t come across many of those but as we keep learning we’ll discover many more. One that we have already come across is strings:\n\n\n\nloop.py\n\nphrase = \"Hello Python\"\n\nfor letter in phrase:\n    print(letter)\n\n\nLooping over a string will always give you one letter at a time.\n\n\n\n\n\n\nExercise 2\n\n\n\nExperiment with loop.py and make it loop over both lists and strings.\nanswer\n\n\n\n\nExtended: Ranges of numbers\nThere’s a built in function in Python called range which provides you with numbers in a range. If given one number as an argument it will give you integers, starting from zero and going up to, but not including, the number you gave as an agument. We can put this call to the range function directly into our loop as the object to loop over:\n\n\n\nloop.py\n\nfor number in range(5):\n    print(number)\n\n\nwill print:\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\n0\n1\n2\n3\n4\n\n\nThe range function can also be given two arguments, in which case, the first argument is the number to start counting from and the second argument is used as above:\n\n\n\nloop.py\n\nfor number in range(10, 13):\n    print(number)\n\n\nprinting:\n\n\nTerminal/Command Prompt\n\npython loop.py\n\n\n\n10\n11\n12\n\n\n\n\nExtended: Enumerating\nWhen looping over a list we are provided with one element at a time which we give a name (word in our example earlier) to be used inside the loop body. However, we don’t have any context about, for example, what the index of the item is from the list.\nTo be able to loop over a list and keep track of both the index of the item and the item itself we can use the enumerate function. This function, if given a list, can give to the loop both pieces of information at once.\n                          ↓\nfor index, word in enumerate(my_words):\n    print(word, \"is at index\", index)\n\nSince each time through the loop we are being given not just one piece of information (the element) but two (the index and the element) we need to provide two loop variable names. We do this by giving both names separated by commas in the usual place:\n      ↓     ↓\nfor index, word in enumerate(my_words):\n    print(word, \"is at index\", index)\n\n\n\n\n\n\n\nExercise 3\n\n\n\nWrite a script (loop_exercise.py) which creates a list of floats and loops over them, printing the index of the element as well as the value of the float.\nanswer",
    "crumbs": [
      "Loops"
    ]
  },
  {
    "objectID": "pages/05-conditionals.html",
    "href": "pages/05-conditionals.html",
    "title": "Conditionals",
    "section": "",
    "text": "We’ve seen loops are one way of changing the default “top to bottom” reading of Python scripts. Loops are an example of control flow statements. Another very useful tool in Python is the conditional. This, rather than allowing you to repeat parts of the program, gives you the ability to skip parts depending on certain conditions.\nThe simplest place to start is the if statement. This lets you only run a block of code if a certain condition is true. Copy the following code into a file called if.py and run it with python if.py in the terminal:\n\n\n\nif.py\n\nmy_number = 128\n\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\n\n\n\nTerminal/Command Prompt\n\npython if.py\n\n\n\n128 is large\n\n\nTo explore the behaviour of the if statement, we could edit the if.py script to change the value of my_number, but instead let’s change it to that it’s set via an input function call. The input function will always return a string, even if you enter digits so we need to explicitly convert the input into an integer with the int function:\n\n\n\nif.py\n\nmy_number = int(input(\"Enter a number: \"))  # We can nest function calls directly\n\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\n\n\n\nTerminal/Command Prompt\n\npython if.py\n\n\n\nEnter a number:  128\n128 is large\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nRun the program with different inputs. Does it give you what you expect? What happens if the input is smaller than 100?\nanswer\n\n\n\nif statement syntax\nAn if statement has a similar sort of structure to a for loop in that it has scaffolding as well as user-supplied parts. The scafolding is the word if and the colon again:\n ↓                ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nand the user-supplied part is the conditional:\n          ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nAs before, the body must be indented by four spaces:\n                colon\n                  ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n  ↑\nindentation\n\n\n\nBooleans\nIf we take a closer look at that user-supplied conditional we’ll see it’s made up of three parts, some data on either side of a greater-than sign (&gt;). In Python this means “is my_number more than 100?”. It’s asking a question and in Python the answer to a question like this can be either True or False.\nFor example,\n\n128 &gt; 100\n\nis True, and:\n\n56 &gt; 100\n\nis False.\nThe results of these questions are booleans. True and False are values in the same way that 12 and \"Hello\" are values but belong to their own data type.\nOther boolean operations we can perform are:\n\n334 &lt; 98  # Less than\n76 == 70 + 6  # Are they equal to each other?\n3.14159 != 3  # Are they *not* equal to each other\n4 &lt;= 43  # Less than or equal to\n45 &gt;= 17  # Greater than or equal to\n\nNotice that when comparing two values, we use a double equals sign (==), wheras we used a single equals sign (=) to create a variable.\nWe also used a # symbol in this code to denote a “comment”. Comments are ignored by Python when running your code which means you can use them to explain to other humans reading your code what it’s doing. This is a good idea if there’s anything non-obvious in your code.\n\n\n\n\n\n\nExercise 2\n\n\n\nExperiment with editing if.py to use some different boolean statements. Make sure you remember to save the file after each change before running it.\nanswer\n\n\n\n\nelse\nWe’ve just seen that the body of an if statement will only run if the conditional is True. But what if we want to do one thing if it’s true, but another if it’s false? We can do this by attaching an else statement to the if statement:\n\n\n\nif.py\n\nmy_number = int(input(\"Enter a number: \"))\n\nif my_number &gt; 100:\n    print(my_number, \"is large\")\nelse:\n    print(my_number, \"is not large\")\n\n\nThe else statement must be at the same level of indentation as the if keyword and does not have any option for the user to provide a boolean statement to it. In this case, you can guarantee that one and only one of the two bodies will run.\n\n\nelif\nIf you do want to provide a boolean statement to an else then you can use an elif instead. It stands for “else, if …” and it allows you to refine the questions you are asking:\n\n\n\nif.py\n\nif my_number &gt; 100:\n    print(my_number, \"is large\")\nelif my_number &lt; 0:\n    print(my_number, \"is negative\")\nelse:\n    print(my_number, \"is not large\")\n\n\nYou can again rely on at most one of the branches being run.\n\n\nOrdering your options\nWhen working out which lines of code will be run, Python will work down the list of if, elifs and else and will run the first one that matches. Once it’s matched one, it will not bother checking to see if any of those later on would have matched. This means that you should order your questions from most-specific to least-specific.\nFor example, if you want to do one thing for positive numbers, but something special instead for numbers greater than 100, then you should put the more specific check first:\n\n\n\nif.py\n\nmy_number = int(input(\"Enter a number: \"))\n\nif my_number &gt; 100:\n    print(my_number, \"is large\")\nelif my_number &gt; 1:\n    print(my_number, \"is positive\")\nelse:\n    print(my_number, \"negative\")\n\n\n\n\nCombining questions\nIt is possible to ask two or more questions in one go by combining them with and and or. So, if you want to check is a number is smaller than ten (my_number &lt; 10) and is not equal to zero (my_number != 0), you can use:\nif my_number &lt; 10 and my_number != 0:\n    ...\nThese combined checks can be used is both if and elif statements.\n\n\n\n\n\n\nExercise 3\n\n\n\nCreate a file leap_year.py which calculates, for a given year, whether it is a leap year and prints out the answer. You might want to read the year in using input, or you could hard-code it in the program.\nThe rules to follow are: 1. if the year is divisible by \\(400\\) then it’s a leap year, 2. otherwise, if the year is divisible by \\(100\\) then it’s not, 3. otherwise, if the year is divisible by \\(4\\) then it’s a leap year, 4. otherwise, it’s not.\nTo simplify the writing of the program, you might find it easier to start with the divisible-by-\\(4\\) condition, then add in the divisible-by-\\(100\\) check and then add in the divisible-by-\\(400\\) calculation.\nFor reference, here are some years for you to check against:\n\n\\(2023\\) - not a leap year as it’s not divisible by \\(4\\)\n\\(2024\\) - a leap year as it’s divisible by \\(4\\) (and not by \\(100\\))\n\\(1900\\) - not a leap year as it’s divisible by \\(100\\) (and not by \\(400\\))\n\\(2000\\) - a leap year as it’s divisible by \\(400\\)\n\nanswer",
    "crumbs": [
      "Conditionals"
    ]
  },
  {
    "objectID": "pages/98-summary.html",
    "href": "pages/98-summary.html",
    "title": "Summary",
    "section": "",
    "text": "Well done for getting this far! We’ve covered a lot in this course:\n\nJupyterLab\nThe print() function\nBasic data types: strings, floats and integers\nIndexing, slicing and appending to lists\nReading Python errors\nBranching logic using if statements\nLooping over different data structures such as lists and dictionaries\nCreating, modifying and accessing dictionaries\n\nYou’re not expected to have committed all of this to memory already, learning any programming language takes more than three hours. It is only by continuing to use Python and practise that you will become confident. These notes will remain online so feel free to refer back to them at any time.\n\nBonus topics\nThere are some topics which are included here as optional extra chapter, if you are interested:\n\nFile reading\n\n\n\nWorksheet\nTo give you something to take away with you to practise with, there is a worksheet with questions. If you get to this point in the session then feel free to start now, otherwise work on them between this session and the next.\n\n\n\n\n\n\nOne Last Challenge\n\n\n\nLet’s end this session with a more difficult challenge. We’re going to make a calculator which can read numerical operations from the input and print the answers to the screen.\nFor example, it should print out an input prompt like\n&gt;\ninto which you can type a calculation as\n&gt; 4 * 6\nand it should then print out the answer like\n&gt; 4 * 6\n4 * 6 is 24\nExamples of inputs it should be able to accept are:\n4 * 6\n5 + 6\n457 - 75\n54 / 3\n4 + 6\nNotice that all the input strings have spaces around the operator, this will make your life much easier if you assume this.\nOne extra function you will need to do this is the split function which takes a string and returns a list containing the string, split by spaces. Also, remember the int function which can convert a string into an integer.\nanswer\n\nBonus\n\nThe examples only have integers in them, can you adjust your program so that it can accept floating point numbers as well?\nCan you adapt your program so that it can support code with or without spaces either side of the operator? This is a more challenging exercise so feel free to ask for some some help and be sure to show one of the instructors your answer once you’ve got it working.\n\nIf you’d like to learn more Python take a look at either:\n\nIntermediate Python for more information about Python and how to make your code modular and reusable.\nIntroduction to Data Analysis in Python to learn about how Python can aid your data analyses.",
    "crumbs": [
      "Summary"
    ]
  }
]